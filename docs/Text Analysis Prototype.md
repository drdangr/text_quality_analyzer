# Прототип системы анализа текста: оценка сложности, сигнальности и семантической функции

## Цели и задачи

**Цель**: создать инструмент, который позволяет автору анализировать текст по нескольким параметрам, чтобы:

- улучшить читаемость и восприятие;
    
- оценивать смысловую плотность и отклонения от темы;
    
- классифицировать фрагменты по их семантической функции (раскрытие темы, метафора, пояснение, шутка и т.д.);
    
- визуализировать результат в наглядной форме.
    

**Основные задачи:**

1. Автоматически разбивать текст на смысловые блоки.
    
2. Оценивать каждый блок по трём направлениям:
    
    - читаемость (сложность);
        
    - соотношение сигнал/шум (близость к теме);
        
    - семантическая функция (OpenAI API или zero-shot классификация если API недоступен);
        
3. Представлять результат в виде тепловой карты и табличного отчёта.
    
4. Подготовить интерфейс ввода/вывода с возможностью масштабирования.
    

**Новая стратегия выполнения:**

- При запуске основной программы (`main.py`) текст разбивается на абзацы и заносится в первый столбец общей таблицы (`pandas.DataFrame`).
    
- Все модули записывают свои результаты в эту общую таблицу, каждый в **свою колонку**:
    
    - 1-й столбец — исходные абзацы,
        
    - 2-й — результат первого модуля (читаемость),
        
    - 3-й — результат второго модуля (сигнал/шум),
        
    - 4-й — результат третьего модуля (семантическая функция).
        

**Важное уточнение:**

- **Модуль 3.1 (через API)** обрабатывает текст как **единый блок**, передаёт его в одном запросе и возвращает список меток по абзацам.
    
- **В случае fallback (отказа API)** модуль 3.2 обрабатывает каждый абзац отдельно, по строкам первого столбца, аналогично первым двум модулям.
    

---

## Архитектура: четыре подмодуля оценки

### 1. Модуль оценки читаемости (`analysis/readability.py`)

**Цель:** измерить формальную читаемость (трудность восприятия) каждого смыслового блока текста.

**Метрики:**

- `LIX` — рассчитывается на базе длины слов и количества длинных слов (>6 символов) на предложение. Используется собственная реализация, адаптированная под русский язык.
    
- `SMOG` — адаптированная версия, вычисляется через количество сложных слов (с 3+ слогами) и количество предложений. Предложения разбиваются через `rusenttokenize`, слова — по регулярному выражению.
    

**Нормализация:**

- LIX и SMOG нормализуются относительно эмпирически подобранных границ (например, шкала LIX: [0–80+], SMOG: [3–18]).
    
- Если SMOG не может быть вычислен (меньше 3 предложений), сложность рассчитывается только по LIX.
    

**Выходные значения:**

- `lix`: float
    
- `smog`: float (или None)
    
- `complexity`: нормализованное среднее значение (LIX и SMOG, если обе доступны)
    

**Режим работы:** модуль получает список всех абзацев, обрабатывает их и возвращает список результатов. Результаты записываются в соответствующую колонку общей таблицы.

---

### 2. Модуль оценки Сигнал/Шум (`analysis/signal_strength.py`)

**Цель:** оценить, насколько каждый смысловой блок близок к основной теме текста (semantic alignment).

**Методика:**

- Используется модель `intfloat/multilingual-e5-large`, ориентированная на сопоставление query/passage.
    
- Вектор темы (`topic_embedding`) рассчитывается на основе темы, введённой пользователем.
    
- Вектор каждого блока сравнивается с темой по **косинусной близости**.
    

**Результат:** значение от 0 до 1 — чем выше, тем ближе блок к заявленной теме.

**Примеры применения:**

- отфильтровывать шумовые или чрезмерно отвлечённые участки текста;
    
- понимать, где автор «уходит» от заданного направления.
    

**Режим работы:** модуль получает список всех абзацев, обрабатывает их и возвращает список результатов. Результаты записываются в соответствующую колонку общей таблицы.

---

### 3. Модуль семантической классификации (`analysis/semantic_function.py`)

**Цель:** определить, **какую роль играет абзац** в структуре текста: поясняет ли он тему, даёт ли пример, создаёт ли паузу, вводит ли образное выражение или шутку.

**Подход:** реализованы два режима работы:

#### 3.1. Основной метод — через OpenAI API (ChatGPT)

**Когда используется:** если переменная `OPENAI_API_KEY` задана в `.env` и подключение к API успешно.

**Механика:**

- При запуске, перед отправкой запроса в OpenAI, вызывается функция `prepare_numbered_text_block(df: pd.DataFrame)`, которая нумерует абзацы (1., 2., 3., ...) из первого столбца общей таблицы и соединяет их двойными переводами строк (`\n\n`) в единый `text_block`.
    
- Этот блок вставляется в шаблон запроса вместо плейсхолдера `<НУМЕРОВАННЫЙ ТЕКСТ>`.
    
- Внутри шаблона, плейсхолдер `<ТЕМА>` также заменяется на тему из `config.py`.
    
- Итоговая конструкция (инструкция + метки + текст) передаётся в одном `user`-сообщении через Chat Completions API.
    

**Формат system/user-сообщений для API:**

```
[
  {"role": "system", "content": "Ты — языковой аналитик. Классифицируй текст по ролям."},
  {"role": "user", "content": "Задание: Определи одну или две наиболее подходящие семантические роли каждого абзаца из списка ниже.\n\nВозможные роли:\n\n1. раскрытие темы — фрагмент расширяет, развивает или продолжает основную тему: '<ТЕМА>'\n2. пояснение на примере — фрагмент иллюстрирует тему '<ТЕМА>' с помощью конкретного случая, аналога или бытовой ситуации\n3. лирическое отступление — содержательное отступление от темы '<ТЕМА>', предлагающее культурное, философское или эмоциональное размышление\n4. ключевой тезис — краткая формулировка центральной мысли или главного вывода по теме '<ТЕМА>', часто лаконична и утверждающая\n5. шум — фрагмент не имеет отношения к теме '<ТЕМА>' и не добавляет ценности обсуждению\n6. метафора / аналогия — образное или переносное выражение, сравнение, аллегория\n7. юмор / ирония / сарказм — элементы, предназначенные вызвать улыбку, комический эффект или критическое осмысление через иронию\n8. связующий переход — фраза или предложение, служащее мостом между частями текста\n9. смена темы — явное или скрытое переключение внимания с одной темы на другую\n10. противопоставление / контраст — фрагмент подчёркивает различие, оппозицию или конфликт идей\n\nОтвет: укажи для каждого абзаца только одну или две роли, точно как в списке выше, без дополнительных пояснений.\n\n<НУМЕРОВАННЫЙ ТЕКСТ>"}
]
```

**Формат ответа:**

```
1. раскрытие темы
2. юмор / ирония / сарказм
3. лирическое отступление
...
```

**Парсинг:**

- Ответ разбивается по строкам.
    
- Каждая строка сопоставляется с номером абзаца.
    
- Метки заносятся в колонку таблицы.
    

**Группы меток:**

- Метки, в которые подставляется тема (`<ТЕМА>`):
    
    - раскрытие темы
        
    - пояснение на примере
        
    - лирическое отступление
        
    - ключевой тезис
        
    - шум
        
- Метки без подстановки темы:
    
    - метафора / аналогия
        
    - юмор / ирония / сарказм
        
    - связующий переход
        
    - смена темы
        
    - противопоставление / контраст
#### 3.2. Резервный метод — локальная zero-shot классификация (fallback)

**Когда используется:** если API недоступно.

**Набор меток:**

- `раскрытие темы`
    
- `пояснение на примере`
    
- `метафора`
    
- `юмор`
    
- `лирическое отступление`
    

**Словарь гипотез:**

```
label_synonyms = {
  "раскрытие темы": [
    "объясняет суть темы",
    "развивает тему",
    "непосредственно относится к теме",
    "конкретизирует тему",
    "продолжает изложение темы"
  ],
  "пояснение на примере": [
    "разъясняет тему через пример",
    "иллюстрирует тему",
    "объясняет идею с помощью аналога",
    "даёт пример по теме",
    "конкретизирует тему бытовой ситуацией"
  ],
  "метафора": [
    "это метафора",
    "это образное выражение",
    "это переносный смысл",
    "это поэтическое сравнение",
    "это аналогия"
  ],
  "юмор": [
    "это юмор",
    "это ирония",
    "это шутка",
    "это сарказм",
    "это комическая вставка"
  ],
  "лирическое отступление": [
    "это содержательное отступление от темы",
    "философское или культурное отступление",
    "не о теме напрямую, но создаёт глубину",
    "содержит мысль, не связанную с темой напрямую",
    "расширяет контекст, отступая от основной линии"
  ]
}
```

**Технические детали:**

- Гипотезы для меток, связанных с темой (`раскрытие темы`, `пояснение`, `лирическое отступление`) формулируются с подстановкой темы из `config.py`:
    

```
hypothesis_template = "Этот фрагмент касается темы '<TOPIC>' и {}."
```

- Каждая метка проверяется по **множеству гипотез**.
    
- Если хотя бы одна гипотеза получает высокий `score`, она считается сработавшей.
    
- На выходе сохраняется только ключ метки (например, `юмор`), независимо от точного текста гипотезы.
    
- Разрешается top-2 ролей с их `score`.
    

**Используемая модель:**

- `MoritzLaurer/mDeBERTa-v3-base-mnli-xnli`
    
- Поддерживает `multi_label=True`
    

### 4. Модуль анализа структуры текста (в перспективе)

**Имя файла:** `analysis/flow_analysis.py`

**Назначение:** перейти от анализа отдельных абзацев к выявлению **структурных паттернов**: темп, насыщенность, перемены в логике изложения, волны внимания, связность между фрагментами.

**Возможности:**

- сравнивать смысловые резюме соседних абзацев;
    
- находить моменты «поворота» — где тема резко меняется;
    
- определять зоны плотности и разреженности;
    
- строить кривую напряжения или смыслового насыщения.
    

**Состояние:** пока не реализован. Обсуждение логики будет происходить отдельно после завершения трёх базовых модулей.

---

## Модуль интерфейса (`interface/ui.py`)

**Назначение:** предоставить простой способ взаимодействия с системой анализа текста.

**Базовая логика:**

- Входной текст задается через переменную пути к `.md`-файлу (в перспективе — редактор внутри оболочки).
    
- Тематика текста указывается вручную (в файле конфигурации или через переменные окружения).
    
- Все модули запускаются **последовательно**, каждый модуль записывает в общий датафрейм результаты анализа по абзацам.
    
- Таблица формируется в `main.py`, первый столбец — список абзацев, все остальные — результат работы модулей.
    

**Выходные формы:**

- Табличный отчёт (CSV/JSON) с результатами всех трёх модулей по каждому параграфу.
    
- Визуализация в виде интерактивной тепловой карты (`plotly`), показывающая по осям:
    
    - номер блока
        
    - сложность, сигнальность и семантическую роль (через цветовые шкалы).
        

**Планируемые улучшения:**

- текстовый редактор с боковой панелью, отображающей оценки по блокам;
    
- выборочное включение/отключение модулей;
    
- сравнение версий текста по разным метрикам.
    

**Шаблон кода для сохранения финальной таблицы:**

```
import pandas as pd

def save_results_table(table: pd.DataFrame, path: str):
    table.to_csv(path + "/result.csv", index=False)
    table.to_json(path + "/result.json", orient="records", force_ascii=False, indent=2)
```