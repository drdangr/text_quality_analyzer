# Новая архитектура системы чанков

## Обзор

Данный документ описывает новую архитектуру системы анализа текста, основанную на концепции чанков как "указателей" на части текста с постоянными UUID. Архитектура решает проблемы синхронизации между панелями, дублирования данных и нестабильности метрик.

## Ключевые принципы

### 1. Единый источник правды
- **Один источник текста**: `DocumentState.text` - единственное место хранения текста
- **Чанки как указатели**: не содержат текст, только позиции и метрики
- **Постоянные идентификаторы**: UUID чанков не меняются при редактировании

### 2. Разделение ответственности
- **Frontend**: быстрые операции (чанкирование, обновление позиций)
- **Backend**: медленные операции (анализ метрик)
- **Асинхронность**: метрики не блокируют редактирование

### 3. Минимизация конфликтов
- **Отсутствие дублирования**: нет виртуальных абзацев
- **Простая синхронизация**: все панели работают с одним состоянием
- **Версионность**: отслеживание актуальности метрик

## Структура данных

### DocumentState
```typescript
interface DocumentState {
  text: string;  // Единственный источник текста
  chunks: Chunk[];
  version: number;  // Для отслеживания изменений
}

interface Chunk {
  id: string;        // UUID - постоянный идентификатор
  start: number;     // Начальная позиция в тексте (включительно)
  end: number;       // Конечная позиция в тексте (исключительно)
  metrics: ChunkMetrics;
}

interface ChunkMetrics {
  // Локальные метрики (быстрые)
  signal_strength?: number;
  complexity?: number;
  semantic_function?: string;
  
  // Контекстуальные метрики (медленные)
  context_relevance?: number;
  global_coherence?: number;
  
  // Метаданные
  isStale?: boolean;        // Нужно обновить
  lastUpdated?: number;     // Timestamp
  version?: number;         // Версия при последнем обновлении
}
```

## Управление чанками

### Создание чанков
1. **При загрузке документа**: разбиение по регулярному выражению `\n\n+`
2. **При редактировании**: автоматическое разделение при появлении `\n\n`
3. **Границы чанков**: ставятся ПОСЛЕ последнего `\n` без изменения пользовательского текста

### Обновление позиций
При любом изменении текста:
1. Определить затронутые чанки
2. Обновить позиции всех чанков после точки изменения
3. Создать/удалить чанки при необходимости
4. Пометить затронутые чанки как `isStale`

### Алгоритм обновления позиций
```typescript
function updateChunkPositions(
  chunks: Chunk[], 
  changeStart: number, 
  changeEnd: number, 
  newText: string
): Chunk[] {
  const delta = newText.length - (changeEnd - changeStart);
  
  return chunks.map(chunk => {
    if (chunk.end <= changeStart) {
      // Чанк до изменения - не трогаем
      return chunk;
    } else if (chunk.start >= changeEnd) {
      // Чанк после изменения - сдвигаем
      return {
        ...chunk,
        start: chunk.start + delta,
        end: chunk.end + delta
      };
    } else {
      // Чанк пересекается с изменением - пересчитываем
      return recalculateChunk(chunk, changeStart, changeEnd, newText);
    }
  });
}
```

## Перетаскивание абзацев

### Концепция
Перетаскивание абзацев полностью вписывается в архитектуру чанков:

1. **При drop**: пересчитываем таблицу чанков от точки вставки до конца
2. **Изменяем**: ID и границы перетащенного абзаца
3. **Инкрементируем**: ID и границы всех последующих чанков
4. **Обновляем**: исходный текст в `DocumentState.text`
5. **Синхронизируем**: все панели получают обновленное состояние

### Алгоритм перетаскивания
```typescript
function moveChunk(
  state: DocumentState,
  sourceChunkId: string,
  targetPosition: number
): DocumentState {
  // 1. Извлекаем текст перетаскиваемого чанка
  const sourceChunk = state.chunks.find(c => c.id === sourceChunkId);
  const chunkText = state.text.slice(sourceChunk.start, sourceChunk.end);
  
  // 2. Удаляем чанк из исходной позиции
  const textWithoutSource = 
    state.text.slice(0, sourceChunk.start) + 
    state.text.slice(sourceChunk.end);
  
  // 3. Вставляем в новую позицию
  const newText = 
    textWithoutSource.slice(0, targetPosition) + 
    chunkText + 
    textWithoutSource.slice(targetPosition);
  
  // 4. Пересчитываем все чанки
  const newChunks = recalculateAllChunks(newText);
  
  return {
    text: newText,
    chunks: newChunks,
    version: state.version + 1
  };
}
```

## Стратегия обновления метрик

### Типы метрик
1. **Локальные** (быстрые): обновляются после каждого действия
   - signal_strength
   - complexity
   - semantic_function

2. **Контекстуальные** (медленные): обновляются после завершения слова
   - context_relevance
   - global_coherence

### Батчинг запросов
```typescript
interface MetricsUpdateQueue {
  localUpdates: Set<string>;      // Chunk IDs для локальных метрик
  contextualUpdates: Set<string>; // Chunk IDs для контекстуальных метрик
  debounceTimer?: number;
}
```

### Индикаторы состояния
- **isStale**: метрики требуют обновления
- **isUpdating**: метрики обновляются в данный момент
- **lastUpdated**: timestamp последнего обновления

## Интеграция с Monaco Editor

### Преимущества Monaco
1. **Точные события изменений**: `onDidChangeContent` с детальной информацией
2. **Профессиональный редактор**: подсветка синтаксиса, автодополнение
3. **Производительность**: оптимизирован для больших текстов
4. **API для управления**: программное изменение текста без событий

### События изменений
```typescript
editor.onDidChangeContent((e) => {
  e.changes.forEach(change => {
    updateChunksForChange({
      start: change.rangeOffset,
      end: change.rangeOffset + change.rangeLength,
      newText: change.text
    });
  });
});
```

## Backend API

### Новые эндпоинты
```python
# Анализ метрик для чанков
POST /api/analyze/chunks
{
  "chunks": [
    {
      "id": "uuid",
      "text": "текст чанка",
      "context": "окружающий контекст"
    }
  ],
  "analysis_type": "local" | "contextual" | "full"
}

# Получение метрик
GET /api/chunks/{chunk_id}/metrics

# Обновление метрик
PUT /api/chunks/{chunk_id}/metrics
{
  "signal_strength": 0.8,
  "complexity": 0.6,
  "version": 123
}
```

### Изменения в существующих эндпоинтах
- **Удаление**: обновление текста из API анализа
- **Фокус**: только на вычислении метрик
- **Версионность**: проверка актуальности данных

## Синхронизация панелей

### Центральное состояние
```typescript
// Zustand store
interface AppState {
  document: DocumentState;
  ui: {
    activePanel: string;
    selectedChunks: string[];
    metricsQueue: MetricsUpdateQueue;
  };
  
  // Actions
  updateText: (newText: string, changeInfo: ChangeInfo) => void;
  moveChunk: (sourceId: string, targetPosition: number) => void;
  updateMetrics: (chunkId: string, metrics: Partial<ChunkMetrics>) => void;
}
```

### Реактивность панелей
1. **TextEditor**: подписан на `document.text`
2. **CardView**: подписан на `document.chunks`
3. **SemanticMap**: подписан на `document.chunks` с метриками

## План внедрения

### Этап 1: Базовая инфраструктура ✅ ЗАВЕРШЕН
- [x] 1.1. Создание новых типов данных (DocumentState, Chunk, ChunkMetrics)
- [x] 1.2. Настройка Zustand store с новой архитектурой
- [x] 1.3. Базовые функции управления чанками (создание, обновление позиций)
- [x] 1.4. Тесты для алгоритмов обновления позиций (тестовый компонент создан)
- [x] 1.5. **Исправление критических ошибок в логике чанков** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 1.6. **Тестирование всех сценариев использования** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 1.7. **Валидация производственной готовности** ⭐ ДОПОЛНИТЕЛЬНО

**Выполнено:**
- ✅ Созданы типы данных в `src/types/chunks.ts`
- ✅ Реализованы утилиты в `src/utils/chunkUtils.ts`
- ✅ Создан новый store `src/store/documentStore.ts`
- ✅ Добавлен тестовый компонент `src/components/TestChunks.tsx`
- ✅ Установлены зависимости: uuid, @types/uuid, zustand
- ✅ Настроен тестовый роут `/test-chunks` или `?test=chunks`
- ✅ Исправлена сортировка чанков по позиции (вместо UUID)
- ✅ **Исправлена функция `shouldCreateNewChunks` для правильного определения создания чанков**
- ✅ **Исправлена функция `updateChunkPositions` для корректной обработки изменений в конце документа**
- ✅ **Протестированы все критические сценарии: создание, объединение, редактирование, удаление**
- ✅ **Подтверждена правильная работа асинхронного обновления метрик**
- ✅ **Система готова к интеграции с существующими панелями**

**Доступ к тестированию:** http://localhost:5173/?test=chunks

**🎯 РЕЗУЛЬТАТ:** Базовая архитектура чанков полностью функциональна и протестирована. Система стабильна и готова для следующего этапа.

### Этап 2: Monaco Editor интеграция ✅ ЗАВЕРШЕН
- [x] 2.1. Установка и настройка Monaco Editor
- [x] 2.2. Замена текущего редактора на Monaco
- [x] 2.3. Интеграция событий изменений с системой чанков
- [x] 2.4. Тестирование производительности на больших текстах
- [x] 2.5. **Тестирование точности ChangeInfo** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 2.6. **Валидация инкрементальных обновлений** ⭐ ДОПОЛНИТЕЛЬНО

**Выполнено:**
- ✅ Установлены пакеты: @monaco-editor/react, monaco-editor
- ✅ Создан компонент MonacoEditor с интеграцией системы чанков  
- ✅ Заменен textarea на Monaco Editor в тестовом компоненте
- ✅ Настроены точные события onDidChangeModelContent
- ✅ Реализована интеграция с ChangeInfo для инкрементальных обновлений
- ✅ **Протестированы все критические сценарии: вставка в конце, середине, создание чанков**
- ✅ **Подтверждены преимущества над textarea: точность, производительность**
- ✅ **Добавлена защита от ошибок и автовосстановление**

**🎯 РЕЗУЛЬТАТ:** Monaco Editor полностью интегрирован и обеспечивает точные инкрементальные обновления системы чанков. Производительность и точность значительно улучшены.

### Этап 3: Обновление панелей ✅ ЗАВЕРШЕН
- [x] 3.1. Рефакторинг CardView под новую архитектуру
- [x] 3.2. Обновление SemanticMap для работы с чанками  
- [x] 3.3. Удаление старой логики виртуальных абзацев
- [x] 3.4. Тестирование синхронизации между панелями
- [x] 3.5. **Полный рефакторинг TextEditorPanel с Monaco Editor** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.6. **Создание CardDeckPanelV2 с нативной поддержкой чанков** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.7. **Удаление всего legacy кода (migrationAdapter, V1 компоненты)** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.8. **Исправление всех edge cases (добавление, удаление, объединение чанков)** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.9. **Добавление автоматической коррекции границ чанков** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.10. **Детальная диагностика и валидация системы** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.11. **Восстановление всех утраченных функций (drag-and-drop, слияние, настройки)** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.12. **Исправление проблем с Monaco Editor (uncaught exceptions)** ⭐ ДОПОЛНИТЕЛЬНО

**Выполнено:**
- ✅ Создан TextEditorPanelV2.tsx (588 строк) с нативной поддержкой чанков
- ✅ Создан CardDeckPanelV2.tsx (500+ строк) с полным функционалом: drag-and-drop, heat map, настройки
- ✅ Обновлен SemanticMapPanel для работы с V2 архитектурой
- ✅ Полностью удалены: migrationAdapter.ts, TextEditorPanel/index.tsx (V1), CardDeckPanel/index.tsx (V1), TestMigration.tsx
- ✅ Убраны virtualParagraphs из appStore.ts
- ✅ Обновлен App.tsx для чистой V2 архитектуры (убраны переключатели V1/V2)
- ✅ **Исправлена система чанкирования: правильное разделение по двойным переводам строк**
- ✅ **Реализована обработка реального времени: мгновенное создание/объединение чанков**
- ✅ **Добавлена автоматическая коррекция границ чанков при любых изменениях**
- ✅ **Протестированы все критические сценарии: создание, редактирование, удаление, объединение**
- ✅ **Восстановлены все 6 утраченных функций:**
  - Кнопка настроек внешнего вида (⚙️) с цветовыми схемами и шрифтами
  - Кнопка слияния (+) с правильным объединением чанков
  - Heat Map (🗺️) с интерактивными кубиками и скроллингом
  - Кнопка удаления (×) карточек
  - Drag-and-drop с реальной перестановкой текста чанков
  - Общие метрики документа с цветовой индикацией
- ✅ **Исправлены критические проблемы Monaco Editor (automaticLayout, uncaught exceptions)**
- ✅ **Система полностью стабильна и готова к интеграции с новыми backend эндпоинтами**

**🎯 РЕЗУЛЬТАТ:** Все панели полностью переработаны под новую архитектуру чанков. Legacy код удален. Вся утраченная функциональность восстановлена. Frontend визуальная часть завершена, потребуются только небольшие изменения для интеграции с новыми API эндпоинтами.

### Этап 4: Backend рефакторинг - Новая архитектура данных ⏳ В ПРОЦЕССЕ

**Ключевые изменения в принципах обработки:**
- **Текст "живет" во frontend**: backend больше не управляет текстом документа
- **Локальные метрики**: отправляем только текст чанка + тема → возвращаем метрики чанка
- **Контекстуальные метрики**: отправляем полный текст + разбивка на чанки → анализ каждого чанка в контексте
- **Индивидуальный анализ**: один запрос = один чанк (вместо пакетной обработки абзацев)
- **Инкрементальные обновления**: frontend решает какие чанки отправлять на анализ

#### Подэтап 4.1: Новые API эндпоинты для семантического анализа (БЕЗ КЕША) ⏳ Планируется
- [ ] 4.1.1. Создание моделей данных для новых запросов
- [ ] 4.1.2. Эндпоинт анализа одного чанка: `POST /api/v1/chunk/metrics/semantic-single`
  - Input: chunk_id, chunk_text, full_text, topic
  - Output: chunk_id + semantic_function
- [ ] 4.1.3. Эндпоинт пакетного анализа: `POST /api/v1/chunks/metrics/semantic-batch`  
  - Input: chunks[], full_text, topic, max_parallel=1
  - Output: results[] с метриками для каждого чанка
- [ ] 4.1.4. Модификация semantic_function.py под новую логику (индивидуальный анализ)
- [ ] 4.1.5. Создание backup существующей функции перед изменениями
- [ ] 4.1.6. Настройка параметра параллельности (начать с 1 для экономии)
- [ ] 4.1.7. Тестирование на реальных данных

#### Подэтап 4.2: Новые API эндпоинты для локальных метрик (БЕЗ КЕША) ⏳ Планируется  
- [ ] 4.2.1. Эндпоинт для анализа сигнала/шума: `POST /api/v1/chunk/metrics/local`
  - Input: chunk_id, chunk_text, topic
  - Output: chunk_id + signal_strength, complexity, lix, smog
- [ ] 4.2.2. Пакетный эндпоинт: `POST /api/v1/chunks/metrics/batch-local`
- [ ] 4.2.3. Рефакторинг signal_strength.py под работу с отдельными чанками
- [ ] 4.2.4. Рефакторинг readability.py под работу с отдельными чанками
- [ ] 4.2.5. Тестирование точности метрик на индивидуальных чанках

#### Подэтап 4.3: Интеграция с frontend ⏳ Планируется
- [ ] 4.3.1. Обновление frontend API модуля (api/index.ts)
- [ ] 4.3.2. Интеграция новых эндпоинтов с documentStore.ts
- [ ] 4.3.3. Обновление логики processMetricsQueue для новых API
- [ ] 4.3.4. Тестирование полного цикла: frontend → backend → frontend
- [ ] 4.3.5. Удаление старых API эндпоинтов и функций

### Этап 5: Реализация кеширования ⏳ Не начато
- [ ] 5.1. Проектирование системы кеширования
  - Кеш по hash(chunk_text + full_text + topic) для семантики
  - Кеш по hash(chunk_text + topic) для локальных метрик
  - LRU кеш с лимитами: 2 темы × 4 варианта = 8 версий документа
- [ ] 5.2. Реализация in-memory кеша на backend
- [ ] 5.3. Добавление параметра use_cache в эндпоинты
- [ ] 5.4. Логика инвалидации кеша
  - При изменении любого чанка → полная очистка
  - При смене темы → очистка старой темы  
  - По TTL (1 час)
- [ ] 5.5. Интеграция с frontend для управления кешированием
- [ ] 5.6. Тестирование производительности и точности кеша

### Этап 6: Оптимизация и производительность ⏳ Не начато
- [ ] 6.1. Настройка оптимального уровня параллельности запросов к OpenAI
- [ ] 6.2. Мониторинг производительности и стоимости
- [ ] 6.3. Fine-tuning промптов для семантического анализа
- [ ] 6.4. Оптимизация алгоритмов обновления метрик
- [ ] 6.5. Профилирование и устранение узких мест

### Этап 7: Асинхронные метрики и UI улучшения ⏳ Не начато
- [ ] 7.1. Реализация очереди обновления метрик
- [ ] 7.2. Батчинг запросов к backend
- [ ] 7.3. Индикаторы состояния загрузки метрик
- [ ] 7.4. Оптимизация UX (анимации, индикаторы)

### Этап 8: Перетаскивание абзацев ⏳ Не начато

## Риски и митигация

### Производительность
- **Риск**: Обновление позиций O(n) при каждом изменении
- **Митигация**: Оптимизированные алгоритмы, батчинг изменений

### Сложность миграции
- **Риск**: Большой объем изменений может привести к ошибкам
- **Митигация**: Поэтапное внедрение, сохранение старой функциональности

### Синхронизация
- **Риск**: Рассинхронизация между панелями
- **Митигация**: Единое состояние, реактивные обновления

## Заключение

Новая архитектура обеспечивает:
- Стабильную работу всех панелей
- Простую синхронизацию данных
- Высокую производительность
- Возможность расширения функциональности

Поэтапное внедрение минимизирует риски и позволяет тестировать каждый компонент отдельно. 