# Новая архитектура системы чанков

## Обзор

Данный документ описывает новую архитектуру системы анализа текста, основанную на концепции чанков как "указателей" на части текста с постоянными UUID. Архитектура решает проблемы синхронизации между панелями, дублирования данных и нестабильности метрик.

## Ключевые принципы

### 1. Единый источник правды
- **Один источник текста**: `DocumentState.text` - единственное место хранения текста
- **Чанки как указатели**: не содержат текст, только позиции и метрики
- **Постоянные идентификаторы**: UUID чанков не меняются при редактировании

### 2. Разделение ответственности
- **Frontend**: быстрые операции (чанкирование, обновление позиций)
- **Backend**: медленные операции (анализ метрик)
- **Асинхронность**: метрики не блокируют редактирование

### 3. Минимизация конфликтов
- **Отсутствие дублирования**: нет виртуальных абзацев
- **Простая синхронизация**: все панели работают с одним состоянием
- **Версионность**: отслеживание актуальности метрик

## Структура данных

### DocumentState
```typescript
interface DocumentState {
  text: string;  // Единственный источник текста
  chunks: Chunk[];
  version: number;  // Для отслеживания изменений
}

interface Chunk {
  id: string;        // UUID - постоянный идентификатор
  start: number;     // Начальная позиция в тексте (включительно)
  end: number;       // Конечная позиция в тексте (исключительно)
  metrics: ChunkMetrics;
}

interface ChunkMetrics {
  // Локальные метрики (быстрые)
  signal_strength?: number;
  complexity?: number;
  semantic_function?: string;
  
  // Контекстуальные метрики (медленные)
  context_relevance?: number;
  global_coherence?: number;
  
  // Метаданные
  isStale?: boolean;        // Нужно обновить
  lastUpdated?: number;     // Timestamp
  version?: number;         // Версия при последнем обновлении
}
```

## Управление чанками

### Создание чанков
1. **При загрузке документа**: разбиение по регулярному выражению `\n\n+`
2. **При редактировании**: автоматическое разделение при появлении `\n\n`
3. **Границы чанков**: ставятся ПОСЛЕ последнего `\n` без изменения пользовательского текста

### Обновление позиций
При любом изменении текста:
1. Определить затронутые чанки
2. Обновить позиции всех чанков после точки изменения
3. Создать/удалить чанки при необходимости
4. Пометить затронутые чанки как `isStale`

### Алгоритм обновления позиций
```typescript
function updateChunkPositions(
  chunks: Chunk[], 
  changeStart: number, 
  changeEnd: number, 
  newText: string
): Chunk[] {
  const delta = newText.length - (changeEnd - changeStart);
  
  return chunks.map(chunk => {
    if (chunk.end <= changeStart) {
      // Чанк до изменения - не трогаем
      return chunk;
    } else if (chunk.start >= changeEnd) {
      // Чанк после изменения - сдвигаем
      return {
        ...chunk,
        start: chunk.start + delta,
        end: chunk.end + delta
      };
    } else {
      // Чанк пересекается с изменением - пересчитываем
      return recalculateChunk(chunk, changeStart, changeEnd, newText);
    }
  });
}
```

## Перетаскивание абзацев

### Концепция
Перетаскивание абзацев полностью вписывается в архитектуру чанков:

1. **При drop**: пересчитываем таблицу чанков от точки вставки до конца
2. **Изменяем**: ID и границы перетащенного абзаца
3. **Инкрементируем**: ID и границы всех последующих чанков
4. **Обновляем**: исходный текст в `DocumentState.text`
5. **Синхронизируем**: все панели получают обновленное состояние

### Алгоритм перетаскивания
```typescript
function moveChunk(
  state: DocumentState,
  sourceChunkId: string,
  targetPosition: number
): DocumentState {
  // 1. Извлекаем текст перетаскиваемого чанка
  const sourceChunk = state.chunks.find(c => c.id === sourceChunkId);
  const chunkText = state.text.slice(sourceChunk.start, sourceChunk.end);
  
  // 2. Удаляем чанк из исходной позиции
  const textWithoutSource = 
    state.text.slice(0, sourceChunk.start) + 
    state.text.slice(sourceChunk.end);
  
  // 3. Вставляем в новую позицию
  const newText = 
    textWithoutSource.slice(0, targetPosition) + 
    chunkText + 
    textWithoutSource.slice(targetPosition);
  
  // 4. Пересчитываем все чанки
  const newChunks = recalculateAllChunks(newText);
  
  return {
    text: newText,
    chunks: newChunks,
    version: state.version + 1
  };
}
```

## Стратегия обновления метрик

### Типы метрик
1. **Локальные** (быстрые): обновляются после каждого действия
   - signal_strength
   - complexity
   - semantic_function

2. **Контекстуальные** (медленные): обновляются после завершения слова
   - context_relevance
   - global_coherence

### Батчинг запросов
```typescript
interface MetricsUpdateQueue {
  localUpdates: Set<string>;      // Chunk IDs для локальных метрик
  contextualUpdates: Set<string>; // Chunk IDs для контекстуальных метрик
  debounceTimer?: number;
}
```

### Индикаторы состояния
- **isStale**: метрики требуют обновления
- **isUpdating**: метрики обновляются в данный момент
- **lastUpdated**: timestamp последнего обновления

## Интеграция с Monaco Editor

### Преимущества Monaco
1. **Точные события изменений**: `onDidChangeContent` с детальной информацией
2. **Профессиональный редактор**: подсветка синтаксиса, автодополнение
3. **Производительность**: оптимизирован для больших текстов
4. **API для управления**: программное изменение текста без событий

### События изменений
```typescript
editor.onDidChangeContent((e) => {
  e.changes.forEach(change => {
    updateChunksForChange({
      start: change.rangeOffset,
      end: change.rangeOffset + change.rangeLength,
      newText: change.text
    });
  });
});
```

## Backend API

### Новые эндпоинты
```python
# Анализ метрик для чанков
POST /api/analyze/chunks
{
  "chunks": [
    {
      "id": "uuid",
      "text": "текст чанка",
      "context": "окружающий контекст"
    }
  ],
  "analysis_type": "local" | "contextual" | "full"
}

# Получение метрик
GET /api/chunks/{chunk_id}/metrics

# Обновление метрик
PUT /api/chunks/{chunk_id}/metrics
{
  "signal_strength": 0.8,
  "complexity": 0.6,
  "version": 123
}
```

### Изменения в существующих эндпоинтах
- **Удаление**: обновление текста из API анализа
- **Фокус**: только на вычислении метрик
- **Версионность**: проверка актуальности данных

## Синхронизация панелей

### Центральное состояние
```typescript
// Zustand store
interface AppState {
  document: DocumentState;
  ui: {
    activePanel: string;
    selectedChunks: string[];
    metricsQueue: MetricsUpdateQueue;
  };
  
  // Actions
  updateText: (newText: string, changeInfo: ChangeInfo) => void;
  moveChunk: (sourceId: string, targetPosition: number) => void;
  updateMetrics: (chunkId: string, metrics: Partial<ChunkMetrics>) => void;
}
```

### Реактивность панелей
1. **TextEditor**: подписан на `document.text`
2. **CardView**: подписан на `document.chunks`
3. **SemanticMap**: подписан на `document.chunks` с метриками

## План внедрения

### Этап 1: Базовая инфраструктура ✅ ЗАВЕРШЕН
- [x] 1.1. Создание новых типов данных (DocumentState, Chunk, ChunkMetrics)
- [x] 1.2. Настройка Zustand store с новой архитектурой
- [x] 1.3. Базовые функции управления чанками (создание, обновление позиций)
- [x] 1.4. Тесты для алгоритмов обновления позиций (тестовый компонент создан)
- [x] 1.5. **Исправление критических ошибок в логике чанков** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 1.6. **Тестирование всех сценариев использования** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 1.7. **Валидация производственной готовности** ⭐ ДОПОЛНИТЕЛЬНО

**Выполнено:**
- ✅ Созданы типы данных в `src/types/chunks.ts`
- ✅ Реализованы утилиты в `src/utils/chunkUtils.ts`
- ✅ Создан новый store `src/store/documentStore.ts`
- ✅ Добавлен тестовый компонент `src/components/TestChunks.tsx`
- ✅ Установлены зависимости: uuid, @types/uuid, zustand
- ✅ Настроен тестовый роут `/test-chunks` или `?test=chunks`
- ✅ Исправлена сортировка чанков по позиции (вместо UUID)
- ✅ **Исправлена функция `shouldCreateNewChunks` для правильного определения создания чанков**
- ✅ **Исправлена функция `updateChunkPositions` для корректной обработки изменений в конце документа**
- ✅ **Протестированы все критические сценарии: создание, объединение, редактирование, удаление**
- ✅ **Подтверждена правильная работа асинхронного обновления метрик**
- ✅ **Система готова к интеграции с существующими панелями**

**Доступ к тестированию:** http://localhost:5173/?test=chunks

**🎯 РЕЗУЛЬТАТ:** Базовая архитектура чанков полностью функциональна и протестирована. Система стабильна и готова для следующего этапа.

### Этап 2: Monaco Editor интеграция ✅ ЗАВЕРШЕН
- [x] 2.1. Установка и настройка Monaco Editor
- [x] 2.2. Замена текущего редактора на Monaco
- [x] 2.3. Интеграция событий изменений с системой чанков
- [x] 2.4. Тестирование производительности на больших текстах
- [x] 2.5. **Тестирование точности ChangeInfo** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 2.6. **Валидация инкрементальных обновлений** ⭐ ДОПОЛНИТЕЛЬНО

**Выполнено:**
- ✅ Установлены пакеты: @monaco-editor/react, monaco-editor
- ✅ Создан компонент MonacoEditor с интеграцией системы чанков  
- ✅ Заменен textarea на Monaco Editor в тестовом компоненте
- ✅ Настроены точные события onDidChangeModelContent
- ✅ Реализована интеграция с ChangeInfo для инкрементальных обновлений
- ✅ **Протестированы все критические сценарии: вставка в конце, середине, создание чанков**
- ✅ **Подтверждены преимущества над textarea: точность, производительность**
- ✅ **Добавлена защита от ошибок и автовосстановление**

**🎯 РЕЗУЛЬТАТ:** Monaco Editor полностью интегрирован и обеспечивает точные инкрементальные обновления системы чанков. Производительность и точность значительно улучшены.

### Этап 3: Обновление панелей ✅ ЗАВЕРШЕН
- [x] 3.1. Рефакторинг CardView под новую архитектуру
- [x] 3.2. Обновление SemanticMap для работы с чанками  
- [x] 3.3. Удаление старой логики виртуальных абзацев
- [x] 3.4. Тестирование синхронизации между панелями
- [x] 3.5. **Полный рефакторинг TextEditorPanel с Monaco Editor** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.6. **Создание CardDeckPanelV2 с нативной поддержкой чанков** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.7. **Удаление всего legacy кода (migrationAdapter, V1 компоненты)** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.8. **Исправление всех edge cases (добавление, удаление, объединение чанков)** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.9. **Добавление автоматической коррекции границ чанков** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.10. **Детальная диагностика и валидация системы** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.11. **Восстановление всех утраченных функций (drag-and-drop, слияние, настройки)** ⭐ ДОПОЛНИТЕЛЬНО
- [x] 3.12. **Исправление проблем с Monaco Editor (uncaught exceptions)** ⭐ ДОПОЛНИТЕЛЬНО

**Выполнено:**
- ✅ Создан TextEditorPanelV2.tsx (588 строк) с нативной поддержкой чанков
- ✅ Создан CardDeckPanelV2.tsx (500+ строк) с полным функционалом: drag-and-drop, heat map, настройки
- ✅ Обновлен SemanticMapPanel для работы с V2 архитектурой
- ✅ Полностью удалены: migrationAdapter.ts, TextEditorPanel/index.tsx (V1), CardDeckPanel/index.tsx (V1), TestMigration.tsx
- ✅ Убраны virtualParagraphs из appStore.ts
- ✅ Обновлен App.tsx для чистой V2 архитектуры (убраны переключатели V1/V2)
- ✅ **Исправлена система чанкирования: правильное разделение по двойным переводам строк**
- ✅ **Реализована обработка реального времени: мгновенное создание/объединение чанков**
- ✅ **Добавлена автоматическая коррекция границ чанков при любых изменениях**
- ✅ **Протестированы все критические сценарии: создание, редактирование, удаление, объединение**
- ✅ **Восстановлены все 6 утраченных функций:**
  - Кнопка настроек внешнего вида (⚙️) с цветовыми схемами и шрифтами
  - Кнопка слияния (+) с правильным объединением чанков
  - Heat Map (🗺️) с интерактивными кубиками и скроллингом
  - Кнопка удаления (×) карточек
  - Drag-and-drop с реальной перестановкой текста чанков
  - Общие метрики документа с цветовой индикацией
- ✅ **Исправлены критические проблемы Monaco Editor (automaticLayout, uncaught exceptions)**
- ✅ **Система полностью стабильна и готова к интеграции с новыми backend эндпоинтами**

**🎯 РЕЗУЛЬТАТ:** Все панели полностью переработаны под новую архитектуру чанков. Legacy код удален. Вся утраченная функциональность восстановлена. Frontend визуальная часть завершена, потребуются только небольшие изменения для интеграции с новыми API эндпоинтами.

### Этап 4: Backend рефакторинг - Новая архитектура данных ✅ ЧАСТИЧНО ЗАВЕРШЕН

**Ключевые изменения в принципах обработки:**
- **Текст "живет" во frontend**: backend больше не управляет текстом документа
- **Локальные метрики**: отправляем только текст чанка + тема → возвращаем метрики чанка
- **Контекстуальные метрики**: отправляем полный текст + разбивка на чанки → анализ каждого чанка в контексте
- **Индивидуальный анализ**: один запрос = один чанк (вместо пакетной обработки абзацев)
- **Инкрементальные обновления**: frontend решает какие чанки отправлять на анализ

#### Подэтап 4.1: Новые API эндпоинты для семантического анализа ✅ ЗАВЕРШЕН 30.05.2025
- [x] 4.1.1. Создание моделей данных для новых запросов
- [x] 4.1.2. Эндпоинт анализа одного чанка: `POST /api/v1/chunk/metrics/semantic-single`
  - Input: chunk_id, chunk_text, full_text, topic
  - Output: chunk_id + semantic_function
- [x] 4.1.3. Эндпоинт пакетного анализа: `POST /api/v1/chunks/metrics/semantic-batch`  
  - Input: chunks[], full_text, topic, max_parallel=1
  - Output: results[] с метриками для каждого чанка
- [x] 4.1.4. Модификация semantic_function.py под новую логику (индивидуальный анализ)
- [x] 4.1.5. Создание backup существующей функции перед изменениями
- [x] 4.1.6. Настройка параметра параллельности (начать с 1 для экономии)
- [x] 4.1.7. Тестирование на реальных данных

**✅ ВЫПОЛНЕНО 30.05.2025:**
- ✅ Созданы новые эндпоинты в api/routes.py
- ✅ Реализованы модели ChunkSemanticRequest, ChunkSemanticResponse в api/models.py
- ✅ Протестированы через Swagger UI - работают корректно
- ✅ Интегрированы с OpenAI GPT-4o для семантического анализа

#### Подэтап 4.2: Новые API эндпоинты для локальных метрик ✅ ЗАВЕРШЕН 30.05.2025
- [x] 4.2.1. Эндпоинт для анализа сигнала/шума: `POST /api/v1/chunk/metrics/local`
  - Input: chunk_id, chunk_text, topic
  - Output: chunk_id + signal_strength, complexity, lix, smog
- [x] 4.2.2. Пакетный эндпоинт: `POST /api/v1/chunks/metrics/batch-local`
- [x] 4.2.3. Рефакторинг signal_strength.py под работу с отдельными чанками
- [x] 4.2.4. Рефакторинг readability.py под работу с отдельными чанками
- [x] 4.2.5. Тестирование точности метрик на индивидуальных чанках

**✅ ВЫПОЛНЕНО 30.05.2025:**
- ✅ Созданы эндпоинты для локальных метрик (signal_strength, complexity)
- ✅ Интегрированы с EmbeddingService для расчета сигнальности
- ✅ Протестированы через API - возвращают корректные численные значения
- ✅ Реализован пакетный анализ для эффективности

#### Подэтап 4.3: Интеграция с frontend ✅ ЗАВЕРШЕН 30.05.2025
- [x] 4.3.1. Обновление frontend API модуля (api/index.ts)
- [x] 4.3.2. Интеграция новых эндпоинтов с documentStore.ts
- [x] 4.3.3. Обновление логики processMetricsQueue для новых API
- [x] 4.3.4. Тестирование полного цикла: frontend → backend → frontend
- [x] 4.3.5. **КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: проблема с отображением semantic_function** ⭐
- [x] 4.3.6. **Разделение триггеров локального и семантического анализа** ⭐
- [x] 4.3.7. **Улучшение триггеров для backspace, delete, enter** ⭐
- [x] 4.3.8. **Нормализация цветов карточек относительно min/max значений** ⭐
- [x] 4.3.9. **Добавление отладочных логов для диагностики** ⭐

**✅ ВЫПОЛНЕНО 30.05.2025:**
- ✅ Добавлены новые API функции в frontend/my-card-view-app/src/api/index.ts
- ✅ Полностью интегрированы в documentStore.ts с разделением ЭТАП 1 (локальный) и ЭТАП 2 (семантический)
- ✅ **ИСПРАВЛЕНА критическая проблема**: API возвращал `{chunk_id, metrics: {semantic_function}}`, но код обращался к `result.semantic_function` вместо `result.metrics.semantic_function`
- ✅ **РАЗДЕЛЕНЫ процессы анализа**: 
  - `shouldTriggerLocalAnalysis()` - реагирует на любые изменения (буквы, backspace, delete, enter)
  - `shouldTriggerSemanticAnalysis()` - только при завершении мысли (пробелы, знаки препинания)
- ✅ **УЛУЧШЕНА система цветов**: нормализация signal_strength и complexity к диапазону 0-1 относительно min/max среди всех чанков
- ✅ **ДОБАВЛЕНЫ отладочные логи**: полная трассировка передачи текста чанков в API для диагностики кэширования
- ✅ Протестировано на реальных данных - все метрики отображаются и обновляются корректно

**🎯 РЕЗУЛЬТАТ ЭТАПА 4:** Backend API полностью готов и интегрирован с frontend. Все метрики (локальные и семантические) работают корректно. Система триггеров оптимизирована для производительности. Цветовая схема карточек корректно отражает относительные различия между чанками.

#### Подэтап 4.4: Оптимизация кэширования ⚠️ ТРЕБУЕТ ВНИМАНИЯ
- [x] 4.4.1. Диагностика проблем с агрессивным кэшированием
- [ ] 4.4.2. Реализация smart invalidation при изменении текста чанков
- [ ] 4.4.3. Настройка hash-функций для корректного определения изменений

**🔍 ОБНАРУЖЕНА ПРОБЛЕМА 30.05.2025:**
- ⚠️ EmbeddingService использует слишком агрессивное кэширование
- ⚠️ При ручном редактировании чанков кэш не инвалидируется корректно
- ⚠️ Метрики обновляются только при полном пересчете (кнопка "Анализировать текст")
- ✅ Добавлены отладочные логи для диагностики передаваемого текста чанков

### ИТОГИ РАБОТЫ 30.05.2025 🎯

#### ✅ ПОЛНОСТЬЮ ЗАВЕРШЕНО:
1. **Семантический анализ** - исправлена критическая проблема с отображением semantic_function в карточках
2. **Разделение процессов** - локальный и семантический анализ теперь работают независимо с разными триггерами
3. **Улучшенные триггеры** - реакция на все операции редактирования (backspace, delete, enter, печать)
4. **Нормализация цветов** - карточки корректно окрашиваются относительно min/max значений среди всех чанков
5. **Отладочная система** - добавлены логи для диагностики передачи текста в API

#### ⚠️ ВЫЯВЛЕННЫЕ ПРОБЛЕМЫ:
1. **Кэширование** - слишком агрессивное, не инвалидируется при изменении текста чанков
2. **Частичное обновление метрик** - работает только при полном пересчете

#### 📋 СЛЕДУЮЩИЕ ШАГИ:
1. Исправить логику кэширования в EmbeddingService
2. Добавить smart invalidation при изменении текста чанков  
3. Протестировать корректность обновления метрик в реальном времени

## Риски и митигация

### Производительность
- **Риск**: Обновление позиций O(n) при каждом изменении
- **Митигация**: Оптимизированные алгоритмы, батчинг изменений

### Сложность миграции
- **Риск**: Большой объем изменений может привести к ошибкам
- **Митигация**: Поэтапное внедрение, сохранение старой функциональности

### Синхронизация
- **Риск**: Рассинхронизация между панелями
- **Митигация**: Единое состояние, реактивные обновления

## Заключение

Новая архитектура обеспечивает:
- Стабильную работу всех панелей
- Простую синхронизацию данных
- Высокую производительность
- Возможность расширения функциональности

Поэтапное внедрение минимизирует риски и позволяет тестировать каждый компонент отдельно. 